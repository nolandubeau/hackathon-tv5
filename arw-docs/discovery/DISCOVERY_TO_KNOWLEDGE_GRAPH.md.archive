# Discovery Architecture to Knowledge Graph: A Forward-Looking Integration

**How ARW's Layered Discovery Enables Semantic Knowledge Graphs**

---

## Executive Summary

ARW's discovery architecture isn't just about finding content—it's about **building semantic understanding**. The layered discovery system (`.well-known/arw-manifest.json` → dual formats → machine views → chunks) provides the foundation for constructing rich **Knowledge Graphs (KG)** that enable truly intelligent agent navigation.

This document explores the forward-looking integration between ARW's discovery architecture and Knowledge Graph construction, showing how today's discovery layer becomes tomorrow's semantic web.

**Key Insights:**

- **Discovery is Graph Construction** - Each manifest entry becomes a KG node, each relationship becomes an edge
- **Chunk Addressability = Precise Semantics** - Fine-grained content addressing enables sub-document graph relationships
- **Protocols Map to Graph Types** - MCP, ACP, A2A create typed edges in the knowledge graph
- **Progressive Enrichment** - Discovery starts simple, graphs grow richer over time
- **Cross-Site Graphs** - Multiple ARW sites form distributed knowledge networks

---

## Table of Contents

1. [From Discovery to Knowledge Graphs](#from-discovery-to-knowledge-graphs)
2. [The Discovery-to-Graph Pipeline](#the-discovery-to-graph-pipeline)
3. [Graph Node Types](#graph-node-types)
4. [Graph Edge Types](#graph-edge-types)
5. [Chunk-Level Graph Relationships](#chunk-level-graph-relationships)
6. [Protocol-Based Graph Typing](#protocol-based-graph-typing)
7. [Cross-Site Knowledge Networks](#cross-site-knowledge-networks)
8. [Agent Navigation via Knowledge Graphs](#agent-navigation-via-knowledge-graphs)
9. [Practical Examples](#practical-examples)
10. [Implementation Roadmap](#implementation-roadmap)
11. [Future Possibilities](#future-possibilities)

---

## From Discovery to Knowledge Graphs

### The Vision

Every ARW-enabled site is a **knowledge graph waiting to be constructed**. The discovery architecture provides the blueprint; agents build the graph through systematic exploration.

**Traditional Web Discovery:**
```
Agent → Crawl HTML → Extract links → Follow → Parse → Repeat
Result: Unstructured link graph with no semantic meaning
```

**ARW Discovery → Knowledge Graph:**
```
Agent → Fetch /.well-known/arw-manifest.json → Parse structure
     → Build typed graph nodes (pages, chunks, actions, protocols)
     → Create semantic edges (relationships, dependencies, references)
Result: Rich knowledge graph with typed nodes and semantic edges
```

### Why This Matters

**For Agents:**
- Navigate semantically instead of randomly
- Understand relationships before fetching content
- Query graphs instead of crawling sites
- Cache and reuse graph structures

**For Publishers:**
- Declare semantic relationships explicitly
- Enable sophisticated agent behavior
- Track graph-based analytics
- Optimize content for graph queries

**For Users:**
- Get contextually relevant answers faster
- See relationship-based recommendations
- Benefit from cross-site knowledge synthesis
- Experience truly intelligent assistance

---

## The Discovery-to-Graph Pipeline

### Phase 1: Discovery Layer → Graph Schema

**Input:** `/.well-known/arw-manifest.json`

```json
{
  "version": "0.1",
  "profile": "ARW-3",
  "site": {
    "name": "CloudCart",
    "homepage": "https://cloudcart.com"
  },
  "content": [
    {
      "url": "/products/keyboard",
      "machine_view": "/products/keyboard.llm.md",
      "purpose": "product_information",
      "chunks": [
        {"id": "product-specs", "heading": "Specifications"},
        {"id": "product-reviews", "heading": "Reviews"}
      ]
    },
    {
      "url": "/docs/shipping",
      "machine_view": "/docs/shipping.llm.md",
      "purpose": "customer_support"
    }
  ],
  "actions": [
    {
      "id": "add_to_cart",
      "endpoint": "/api/actions/add-to-cart",
      "schema": "https://schema.org/BuyAction"
    }
  ]
}
```

**Output:** Knowledge Graph Schema

```cypher
// Neo4j/Cypher representation

// Site Node
CREATE (site:Site {
  name: "CloudCart",
  url: "https://cloudcart.com",
  arw_profile: "ARW-3"
})

// Page Nodes
CREATE (product_page:Page {
  url: "/products/keyboard",
  machine_view: "/products/keyboard.llm.md",
  purpose: "product_information"
})

CREATE (support_page:Page {
  url: "/docs/shipping",
  machine_view: "/docs/shipping.llm.md",
  purpose: "customer_support"
})

// Chunk Nodes
CREATE (specs_chunk:Chunk {
  id: "product-specs",
  heading: "Specifications",
  parent_url: "/products/keyboard"
})

CREATE (reviews_chunk:Chunk {
  id: "product-reviews",
  heading: "Reviews",
  parent_url: "/products/keyboard"
})

// Action Nodes
CREATE (add_cart_action:Action {
  id: "add_to_cart",
  endpoint: "/api/actions/add-to-cart",
  schema: "https://schema.org/BuyAction"
})

// Relationships (Edges)
CREATE (site)-[:HAS_PAGE]->(product_page)
CREATE (site)-[:HAS_PAGE]->(support_page)
CREATE (product_page)-[:CONTAINS_CHUNK]->(specs_chunk)
CREATE (product_page)-[:CONTAINS_CHUNK]->(reviews_chunk)
CREATE (product_page)-[:ENABLES_ACTION]->(add_cart_action)
```

### Phase 2: Machine Views → Graph Enrichment

**Input:** `/products/keyboard.llm.md`

```markdown
<!-- chunk: product-summary -->
# Wireless Mechanical Keyboard
**Price:** $129.99
**Stock:** In Stock

<!-- chunk: product-specs -->
## Specifications
- Connection: Bluetooth 5.0
- Battery: 40 hours
- Switches: Cherry MX Brown

<!-- chunk: product-reviews -->
## Customer Reviews
**Rating:** 4.9/5 (324 reviews)
```

**Output:** Enriched Graph

```cypher
// Add content attributes to chunk nodes
MATCH (chunk:Chunk {id: "product-specs"})
SET chunk.content = "Connection: Bluetooth 5.0\nBattery: 40 hours...",
    chunk.token_count = 150,
    chunk.topics = ["connectivity", "battery", "switches"]

// Create topic nodes and relationships
CREATE (bluetooth:Topic {name: "Bluetooth 5.0"})
CREATE (cherry:Topic {name: "Cherry MX Brown"})
CREATE (chunk)-[:MENTIONS_TOPIC]->(bluetooth)
CREATE (chunk)-[:MENTIONS_TOPIC]->(cherry)

// Create product entity
CREATE (product:Product {
  name: "Wireless Mechanical Keyboard",
  price: 129.99,
  stock_status: "in_stock",
  rating: 4.9
})
CREATE (product_page)-[:DESCRIBES_PRODUCT]->(product)
```

### Phase 3: Semantic Analysis → Deep Relationships

**Input:** Cross-chunk and cross-page analysis

**Output:** Semantic edges

```cypher
// Find related content
MATCH (keyboard_page:Page)-[:DESCRIBES_PRODUCT]->(keyboard:Product)
MATCH (mouse_page:Page)-[:DESCRIBES_PRODUCT]->(mouse:Product)
WHERE keyboard.topics INTERSECT mouse.topics
CREATE (keyboard)-[:RELATED_TO {reason: "similar_category"}]->(mouse)

// Find relevant support docs
MATCH (product_page:Page {purpose: "product_information"})
MATCH (support_page:Page {purpose: "customer_support"})
WHERE support_page.topics CONTAINS "shipping"
  AND product_page.url CONTAINS "keyboard"
CREATE (product_page)-[:HAS_SUPPORT_DOC]->(support_page)

// Find prerequisite reading
MATCH (advanced_doc:Page)-[:CONTAINS_CHUNK]->(chunk:Chunk)
WHERE chunk.content CONTAINS "assumes knowledge of OAuth"
MATCH (oauth_doc:Page {url: "/docs/oauth"})
CREATE (advanced_doc)-[:REQUIRES_READING]->(oauth_doc)
```

---

## Graph Node Types

ARW discovery naturally maps to a rich type hierarchy:

### Core Node Types

**1. Site Node**
```cypher
(:Site {
  name: string,
  url: string,
  arw_profile: "ARW-1" | "ARW-2" | "ARW-3" | "ARW-4",
  contact: string,
  last_updated: datetime
})
```

**2. Page Node**
```cypher
(:Page {
  url: string,
  machine_view: string,
  purpose: string,
  priority: "high" | "medium" | "low",
  token_count: integer,
  last_modified: datetime
})
```

**3. Chunk Node**
```cypher
(:Chunk {
  id: string,
  heading: string,
  content: string,
  token_count: integer,
  topics: [string],
  addressable_url: string  // page.llm.md#chunk-id
})
```

**4. Action Node**
```cypher
(:Action {
  id: string,
  name: string,
  endpoint: string,
  method: "GET" | "POST" | "PUT" | "DELETE",
  auth: "oauth2" | "api_key" | "none",
  schema: string,  // Schema.org URL
  scopes: [string]
})
```

**5. Protocol Node**
```cypher
(:Protocol {
  name: string,
  type: "mcp" | "acp" | "a2a",
  endpoint: string,
  description: string
})
```

### Extended Node Types (Derived)

**6. Entity Nodes** (extracted from content)
```cypher
(:Product {name, price, sku, rating})
(:Person {name, role, email})
(:Concept {name, definition, category})
(:Topic {name, description, relevance_score})
```

**7. Policy Nodes**
```cypher
(:Policy {
  training_allowed: boolean,
  inference_allowed: boolean,
  attribution_required: boolean,
  rate_limit: string
})
```

---

## Graph Edge Types

Relationships are the semantic glue of knowledge graphs. ARW discovery enables rich edge typing:

### Structural Edges (from Discovery)

**1. Site → Page**
```cypher
(:Site)-[:HAS_PAGE]->(:Page)
```

**2. Page → Chunk**
```cypher
(:Page)-[:CONTAINS_CHUNK {order: integer}]->(:Chunk)
```

**3. Page → Action**
```cypher
(:Page)-[:ENABLES_ACTION]->(:Action)
```

**4. Site → Protocol**
```cypher
(:Site)-[:SUPPORTS_PROTOCOL]->(:Protocol)
```

**5. Site → Policy**
```cypher
(:Site)-[:HAS_POLICY]->(:Policy)
```

### Semantic Edges (from Content Analysis)

**6. Content Relationships**
```cypher
(:Page)-[:RELATED_TO {
  reason: string,
  confidence: float
}]->(:Page)

(:Chunk)-[:REFERENCES {
  context: string
}]->(:Chunk)

(:Page)-[:PREREQUISITE_FOR]->(:Page)
(:Page)-[:FOLLOWS_UP_ON]->(:Page)
```

**7. Entity Relationships**
```cypher
(:Page)-[:DESCRIBES_PRODUCT]->(:Product)
(:Chunk)-[:MENTIONS_TOPIC]->(:Topic)
(:Product)-[:RELATED_TO]->(:Product)
(:Topic)-[:SUBTOPIC_OF]->(:Topic)
```

**8. Action Relationships**
```cypher
(:Action)-[:REQUIRES_PREREQUISITE]->(:Action)
(:Action)-[:MODIFIES_ENTITY]->(:Product)
(:Action)-[:REQUIRES_READING]->(:Page)
```

### Protocol-Based Edges (Section 6)

**9. Cross-Protocol Relationships**
```cypher
(:Protocol {type: "mcp"})-[:PROVIDES_DATA_TO]->(:Protocol {type: "acp"})
(:Action)-[:IMPLEMENTED_VIA]->(:Protocol)
```

---

## Chunk-Level Graph Relationships

Chunk addressability is ARW's secret weapon for **fine-grained knowledge graphs**.

### Why Chunk Graphs Matter

**Problem with Page-Level Graphs:**
```
Page A → Page B
(What exactly relates? The whole page? A paragraph?)
```

**Solution with Chunk-Level Graphs:**
```
Page A / Chunk "oauth-flow" → Page B / Chunk "api-authentication"
(Precise: OAuth flow description relates to API auth overview)
```

### Chunk Graph Example

**Discovery manifest declares chunks:**
```yaml
content:
  - url: /docs/authentication
    chunks:
      - id: oauth-overview
      - id: oauth-flow
      - id: api-keys
  - url: /docs/api/orders
    chunks:
      - id: create-order
      - id: list-orders
```

**Graph construction:**
```cypher
// Chunks are first-class nodes
CREATE (oauth_flow:Chunk {
  id: "oauth-flow",
  page: "/docs/authentication",
  addressable_url: "/docs/authentication.llm.md#oauth-flow"
})

CREATE (create_order:Chunk {
  id: "create-order",
  page: "/docs/api/orders",
  addressable_url: "/docs/api/orders.llm.md#create-order"
})

// Semantic relationship at chunk level
CREATE (create_order)-[:REQUIRES_UNDERSTANDING {
  reason: "OAuth is prerequisite for authenticated API calls"
}]->(oauth_flow)
```

### Agent Query: Chunk-Level Precision

**User:** "How do I create an order with OAuth?"

**Traditional approach:**
- Fetch entire /docs/authentication page (10KB)
- Fetch entire /docs/api/orders page (15KB)
- Parse both, find relevant sections
- Total: 25KB

**ARW Knowledge Graph approach:**
- Query graph: `MATCH (chunk:Chunk {id: "create-order"})-[:REQUIRES_UNDERSTANDING]->(prereq:Chunk)`
- Fetch only: `/docs/authentication.llm.md#oauth-flow` (2KB) + `/docs/api/orders.llm.md#create-order` (3KB)
- Total: 5KB (80% reduction)

**Result:**
- 5x more efficient
- Precise context
- Better understanding
- No irrelevant information

---

## Protocol-Based Graph Typing

ARW's protocol integration (Section 7 of spec) enables **typed knowledge graphs**.

### MCP Protocol → Data Graph

**Discovery declares MCP:**
```yaml
protocols:
  - name: 'Product Catalog MCP Server'
    type: mcp
    endpoint: /api/mcp/v1
    description: 'Real-time product data'
```

**Graph representation:**
```cypher
CREATE (mcp:Protocol {
  name: "Product Catalog MCP Server",
  type: "mcp",
  endpoint: "/api/mcp/v1",
  purpose: "data_access"
})

CREATE (site)-[:SUPPORTS_PROTOCOL]->(mcp)

// MCP exposes data resources
CREATE (inventory:DataResource {
  name: "inventory",
  via_protocol: "mcp",
  endpoint: "/api/mcp/v1/resources/inventory"
})

CREATE (mcp)-[:EXPOSES_RESOURCE]->(inventory)

// Link to product entities
MATCH (product:Product {sku: "KB-WL-001"})
CREATE (product)-[:HAS_DATA_SOURCE]->(inventory)
```

**Agent benefit:** Knows that real-time inventory is available via MCP before fetching anything.

### ACP Protocol → Transaction Graph

**Discovery declares ACP:**
```yaml
protocols:
  - name: 'CloudCart Checkout'
    type: acp
    endpoint: /api/acp/checkout
    description: 'ACP-compliant checkout flow'
```

**Graph representation:**
```cypher
CREATE (acp:Protocol {
  name: "CloudCart Checkout",
  type: "acp",
  endpoint: "/api/acp/checkout",
  purpose: "transaction_flow"
})

// ACP implements specific actions
MATCH (add_cart:Action {id: "add_to_cart"})
MATCH (checkout:Action {id: "checkout"})
CREATE (add_cart)-[:IMPLEMENTED_VIA]->(acp)
CREATE (checkout)-[:IMPLEMENTED_VIA]->(acp)

// Transaction workflow
CREATE (add_cart)-[:PRECEDES {required: true}]->(checkout)
```

**Agent benefit:** Understands transaction flow and protocol requirements before attempting operations.

### A2A Protocol → Agent Graph

**Discovery declares A2A:**
```yaml
protocols:
  - name: 'Customer Support Agent'
    type: a2a
    endpoint: /.well-known/agent
    description: 'Agent card for support automation'
```

**Graph representation:**
```cypher
CREATE (support_agent:AIAgent {
  name: "Customer Support Agent",
  type: "a2a",
  endpoint: "/.well-known/agent",
  capabilities: ["ticket_creation", "order_status", "faq"]
})

// Agent handles specific actions
MATCH (create_ticket:Action {id: "create_support_ticket"})
CREATE (support_agent)-[:HANDLES_ACTION]->(create_ticket)

// Agent has knowledge domains
MATCH (shipping_docs:Page {url: "/docs/shipping"})
CREATE (support_agent)-[:HAS_KNOWLEDGE_OF]->(shipping_docs)
```

**Agent benefit:** Can delegate to specialized agents or collaborate with them.

---

## Cross-Site Knowledge Networks

ARW enables **distributed knowledge graphs** across multiple sites.

### Single-Site vs. Multi-Site Graphs

**Single-Site Graph:**
```
CloudCart.com
  ├── Products
  ├── Documentation
  └── Support
```

**Multi-Site Knowledge Network:**
```
CloudCart.com                  Reviews.com
  ├── Products ←──────────────→ Product Reviews
  ├── Documentation
  └── Support                  PaymentGateway.com
                                 ├── Payment Actions
                                 └── Security Docs ←──→ CloudCart OAuth Docs
```

### Cross-Site Graph Construction

**Site 1: CloudCart**
```yaml
# /.well-known/arw-manifest.json
content:
  - url: /products/keyboard
    machine_view: /products/keyboard.llm.md
    external_refs:
      - rel: reviews
        href: https://reviews.com/products/keyboard
        arw_manifest: https://reviews.com/.well-known/arw-manifest.json
```

**Site 2: Reviews.com**
```yaml
# /.well-known/arw-manifest.json
content:
  - url: /products/keyboard
    machine_view: /products/keyboard.llm.md
    external_refs:
      - rel: product_page
        href: https://cloudcart.com/products/keyboard
        arw_manifest: https://cloudcart.com/.well-known/arw-manifest.json
```

**Unified Knowledge Graph:**
```cypher
// Site nodes
CREATE (cloudcart:Site {name: "CloudCart", url: "https://cloudcart.com"})
CREATE (reviews:Site {name: "Reviews.com", url: "https://reviews.com"})

// Product pages on both sites
CREATE (cc_product:Page {url: "https://cloudcart.com/products/keyboard"})
CREATE (rv_product:Page {url: "https://reviews.com/products/keyboard"})

// Cross-site relationship
CREATE (cc_product)-[:HAS_EXTERNAL_REVIEWS {
  rel: "reviews",
  verified: true
}]->(rv_product)

CREATE (rv_product)-[:REVIEWS_PRODUCT {
  rel: "product_page"
}]->(cc_product)

// Agents can traverse
MATCH path = (product:Page)-[:HAS_EXTERNAL_REVIEWS]->(reviews:Page)
RETURN path
```

### Discovery Flow for Multi-Site Graphs

**Agent scenario:** "Find the best wireless keyboard under $150 with good reviews"

```
1. Query site registry → Find e-commerce sites with ARW
   Result: [cloudcart.com, techshop.com, keyboards.com]

2. Fetch manifests in parallel:
   GET https://cloudcart.com/.well-known/arw-manifest.json
   GET https://techshop.com/.well-known/arw-manifest.json
   GET https://keyboards.com/.well-known/arw-manifest.json

3. Build unified graph:
   Nodes: All products from all sites
   Edges: Products → External Reviews

4. Query unified graph:
   MATCH (product:Product)-[:HAS_EXTERNAL_REVIEWS]->(reviews:Page)
   WHERE product.price < 150
   RETURN product ORDER BY reviews.rating DESC LIMIT 5

5. Fetch only top 5 machine views (not all products)
   Total: ~20KB vs crawling all sites (500KB+)
```

**Result:** 25x more efficient, cross-site semantic understanding.

---

## Agent Navigation via Knowledge Graphs

### Traditional Crawling vs. Graph Navigation

**Traditional Crawling:**
```python
def find_related_docs(url):
    html = fetch(url)
    links = extract_links(html)
    for link in links:
        if "docs" in link:
            # Maybe relevant?
            html = fetch(link)
            # Parse and check...
```
**Problems:** Slow, wasteful, no semantic understanding

**ARW Graph Navigation:**
```python
def find_related_docs(url):
    # Query graph (instant)
    result = graph.query("""
        MATCH (page:Page {url: $url})
              -[:RELATED_TO|PREREQUISITE_FOR|HAS_SUPPORT_DOC*1..2]->
              (related:Page {purpose: "documentation"})
        RETURN related.url, related.machine_view
        ORDER BY relationship.confidence DESC
        LIMIT 5
    """, url=url)

    # Fetch only relevant machine views
    for doc in result:
        content = fetch(doc['machine_view'])
        # Process semantic content
```
**Benefits:** 100x faster, semantic relationships, no wasted fetches

### Graph-Based Query Patterns

**1. Prerequisite Discovery**
```cypher
// Find all prerequisites for a topic
MATCH path = (target:Page {url: "/docs/advanced-oauth"})
             <-[:PREREQUISITE_FOR*]-(prereq:Page)
RETURN prereq.url, prereq.machine_view, length(path) as depth
ORDER BY depth ASC
```

**2. Action Dependency Resolution**
```cypher
// Find all actions needed for a workflow
MATCH (start:Action {id: "create_order"})
      -[:REQUIRES_PREREQUISITE*]->(required:Action)
RETURN required.id, required.endpoint, required.auth
```

**3. Topic Exploration**
```cypher
// Find all content related to a topic
MATCH (chunk:Chunk)-[:MENTIONS_TOPIC]->(topic:Topic {name: "OAuth 2.0"})
RETURN chunk.page, chunk.addressable_url, chunk.heading
```

**4. Cross-Domain Discovery**
```cypher
// Find support docs for any product category
MATCH (product:Page {purpose: "product_information"})
      -[:RELATED_TO {reason: "category"}]->(category)
      <-[:RELATED_TO]-(support:Page {purpose: "customer_support"})
RETURN product.url, support.url
```

---

## Practical Examples

### Example 1: E-Commerce Product Discovery

**User Query:** "Find wireless keyboards with USB-C charging, compare prices, and show shipping options"

**Graph Query:**
```cypher
// Step 1: Find matching products
MATCH (product:Product)-[:HAS_FEATURE]->(usbc:Feature {name: "USB-C"})
WHERE product.category = "keyboard"
  AND product.connectivity CONTAINS "wireless"

// Step 2: Get pricing across sites
MATCH (product)<-[:DESCRIBES_PRODUCT]-(page:Page)<-[:HAS_PAGE]-(site:Site)
WITH product, site, page, product.price as price

// Step 3: Find shipping policies
MATCH (site)-[:HAS_PAGE]->(shipping:Page {purpose: "customer_support"})
WHERE shipping.url CONTAINS "shipping"

RETURN
  product.name,
  site.name,
  price,
  shipping.machine_view,
  page.machine_view as product_page
ORDER BY price ASC
LIMIT 5
```

**Agent executes:**
1. Query graph (instant)
2. Fetch 5 product machine views (25KB)
3. Fetch 5 shipping policy views (15KB)
4. Total: 40KB vs crawling entire sites (5MB+)

**User gets:**
- 5 matching products
- Prices compared
- Shipping policies
- All in < 2 seconds

### Example 2: Technical Documentation Navigation

**User Query:** "I'm getting a 401 error when calling the API"

**Graph Query:**
```cypher
// Find error documentation
MATCH (error:Chunk)
WHERE error.content CONTAINS "401"
  AND error.topics CONTAINS "authentication"

// Find prerequisite reading
MATCH (error)<-[:CONTAINS_CHUNK]-(page:Page)
      <-[:PREREQUISITE_FOR]-(prereq:Page)

// Find related actions
MATCH (action:Action {auth: "oauth2"})
      -[:REQUIRES_READING]->(auth_doc:Page)

RETURN
  error.addressable_url as error_docs,
  prereq.machine_view as prerequisites,
  auth_doc.machine_view as auth_guide,
  action.endpoint as relevant_endpoint
```

**Agent executes:**
1. Query graph to find relevant docs
2. Fetch only relevant chunks:
   - Error explanation (1KB)
   - OAuth prerequisite (2KB)
   - Action endpoint docs (2KB)
3. Total: 5KB

**User gets:**
- Exact error explanation
- Why it happened (missing OAuth)
- How to fix it (auth guide)
- Which endpoint to use
- All in < 1 second

### Example 3: Cross-Site Shopping Assistant

**User Query:** "I need a mechanical keyboard. Show me options, reviews, and compatible desks"

**Multi-Site Graph Query:**
```cypher
// Site 1: CloudCart (products)
MATCH (cc:Site {name: "CloudCart"})
      -[:HAS_PAGE]->(product:Page)
      -[:DESCRIBES_PRODUCT]->(kb:Product {category: "keyboard"})
WHERE kb.type = "mechanical"

// Site 2: Reviews (external reviews)
MATCH (product)-[:HAS_EXTERNAL_REVIEWS]->(reviews:Page)
      <-[:HAS_PAGE]-(rv:Site {name: "Reviews.com"})

// Site 3: Furniture (compatible accessories)
MATCH (kb)-[:COMPATIBLE_WITH]->(desk:Product {category: "desk"})
      <-[:DESCRIBES_PRODUCT]-(desk_page:Page)
      <-[:HAS_PAGE]-(furn:Site {name: "FurniturePro"})

RETURN
  kb.name, kb.price, product.machine_view,
  reviews.machine_view,
  desk.name, desk_page.machine_view
ORDER BY reviews.rating DESC
LIMIT 3
```

**Agent executes:**
1. Discover all 3 sites via ARW registry
2. Fetch manifests (15KB total)
3. Build unified graph
4. Query graph for relationships
5. Fetch only top 3 results from each site (45KB total)

**Traditional approach:**
- Crawl all 3 sites (50MB+)
- Parse HTML from hundreds of pages
- Hope to find relationships
- 5-10 minutes

**ARW Graph approach:**
- Query unified graph (instant)
- Fetch only relevant content (45KB)
- Explicit relationships from manifests
- < 3 seconds

---

## Implementation Roadmap

### Phase 1: Foundation (Months 0-3)

**Goal:** Enable basic graph construction from ARW discovery

**Deliverables:**
1. **Graph Schema Definition**
   - Define node types (Site, Page, Chunk, Action, Protocol)
   - Define edge types (structural + semantic)
   - Publish as JSON Schema + OWL ontology

2. **Discovery-to-Graph Pipeline**
   - Parse `/.well-known/arw-manifest.json` → Create nodes
   - Parse relationships from manifest → Create edges
   - Reference implementation (Python + Neo4j)

3. **Chunk Addressability Support**
   - Parse chunk annotations from machine views
   - Create Chunk nodes with precise URLs
   - Enable fragment-based fetching

**Success Criteria:**
- Agent can build graph from single ARW site
- Graph query returns machine view URLs
- Chunk-level relationships work

### Phase 2: Semantic Enrichment (Months 3-6)

**Goal:** Add semantic analysis and cross-content relationships

**Deliverables:**
1. **Content Analysis Pipeline**
   - Extract topics from machine views
   - Identify entity mentions (products, concepts, people)
   - Detect relationships between chunks

2. **Semantic Edge Construction**
   - `RELATED_TO` based on topic overlap
   - `PREREQUISITE_FOR` based on complexity analysis
   - `REFERENCES` based on content analysis

3. **Entity Extraction**
   - Product entities (name, price, SKU, rating)
   - Topic entities (concepts, categories)
   - Link entities to pages and chunks

**Success Criteria:**
- Graph includes semantic relationships beyond manifest
- Topic-based queries work
- Entity-based queries work

### Phase 3: Protocol Integration (Months 6-9)

**Goal:** Integrate MCP, ACP, A2A into knowledge graph

**Deliverables:**
1. **Protocol Node Types**
   - MCP: Data resources, tools
   - ACP: Transaction flows, checkout steps
   - A2A: Agent capabilities, delegation patterns

2. **Protocol-Based Edges**
   - Actions → Protocols (implementation relationship)
   - Protocols → Data (exposure relationship)
   - Agents → Capabilities (delegation relationship)

3. **Cross-Protocol Queries**
   - Find data sources for actions
   - Find transaction implementations
   - Find agent delegation patterns

**Success Criteria:**
- Protocol nodes appear in graph
- Agents can query protocol capabilities
- Action workflows discoverable via graph

### Phase 4: Cross-Site Networks (Months 9-12)

**Goal:** Enable distributed knowledge graphs across multiple ARW sites

**Deliverables:**
1. **Site Registry**
   - Central registry of ARW-enabled sites
   - Metadata about each site (categories, capabilities)
   - Discovery API for finding relevant sites

2. **Cross-Site Graph Construction**
   - Fetch manifests from multiple sites
   - Merge into unified graph
   - Handle site-to-site references

3. **Federated Graph Queries**
   - Query across multiple site graphs
   - Rank results by relevance + confidence
   - Handle graph updates from any site

**Success Criteria:**
- Unified graph spans 10+ sites
- Cross-site queries work
- Sub-2 second query response

### Phase 5: Advanced Features (Months 12+)

**Ongoing:**
1. **Graph Analytics**
   - PageRank for content importance
   - Community detection for topic clusters
   - Anomaly detection for broken links

2. **Machine Learning Integration**
   - Embedding-based similarity
   - Relationship prediction
   - Content recommendation

3. **Graph Optimization**
   - Incremental updates
   - Distributed storage
   - Query optimization

---

## Future Possibilities

### 1. Semantic Web Integration

**Vision:** ARW graphs + RDF/OWL = Full Semantic Web

**Approach:**
- Export ARW graphs as RDF triples
- Map ARW nodes to Schema.org types
- Enable SPARQL queries over ARW data

**Example:**
```turtle
@prefix arw: <https://arw.dev/ontology#> .
@prefix schema: <https://schema.org/> .

<https://cloudcart.com/products/keyboard>
  a arw:Page ;
  arw:machineView <https://cloudcart.com/products/keyboard.llm.md> ;
  arw:describes [
    a schema:Product ;
    schema:name "Wireless Mechanical Keyboard" ;
    schema:price "129.99" ;
    schema:offers [
      a schema:Offer ;
      schema:availability schema:InStock
    ]
  ] .
```

### 2. Decentralized Knowledge Graphs

**Vision:** No central registry, peer-to-peer discovery

**Approach:**
- Each ARW site publishes graph fingerprint
- Sites reference each other via `.well-known/arw-peers`
- Agents build distributed graphs via discovery

**Benefit:** True decentralization, no single point of failure

### 3. Real-Time Graph Updates

**Vision:** Knowledge graphs stay fresh automatically

**Approach:**
- Sites publish event streams (`/.well-known/arw-events`)
- Agents subscribe to updates
- Graph updates incrementally

**Example:**
```json
{
  "event": "content_updated",
  "page": "/products/keyboard",
  "chunk": "product-specs",
  "timestamp": "2025-01-15T10:30:00Z",
  "diff": {
    "price": {"old": "129.99", "new": "119.99"}
  }
}
```

### 4. Collaborative Filtering via Graphs

**Vision:** User behavior enriches knowledge graphs

**Approach:**
- Track which chunks agents fetch together
- Create `FREQUENTLY_ACCESSED_WITH` edges
- Enable collaborative filtering

**Example:**
```cypher
// Users who read OAuth docs also read...
MATCH (oauth:Chunk {id: "oauth-flow"})
      -[:FREQUENTLY_ACCESSED_WITH]->(related:Chunk)
RETURN related.heading, related.addressable_url
ORDER BY relationship.strength DESC
```

### 5. Multi-Modal Knowledge Graphs

**Vision:** Beyond text—images, videos, code

**Approach:**
- ARW extends to support media types
- Graph nodes include embeddings
- Cross-modal relationships

**Example:**
```cypher
CREATE (video:MediaChunk {
  type: "video",
  url: "/tutorials/oauth.mp4",
  timestamp: "00:02:15",
  transcript_chunk: "oauth-flow"
})
CREATE (video)-[:EXPLAINS_VISUALLY]->(oauth:Chunk {id: "oauth-flow"})
```

### 6. Graph-Based Caching

**Vision:** Intelligent caching based on graph structure

**Approach:**
- Cache frequently accessed subgraphs
- Prefetch related content
- Invalidate based on graph changes

**Example:**
If user accesses `/docs/api/orders`, prefetch:
- Prerequisites: `/docs/authentication#oauth-flow`
- Related: `/docs/api/products`
- Support: `/docs/troubleshooting#401-errors`

Total prefetch: 15KB, prevents 3 future requests

---

## Conclusion

ARW's discovery architecture isn't just about finding content—**it's about building understanding**. The layered discovery system provides the blueprint for constructing rich knowledge graphs that enable:

**For Agents:**
- Navigate semantically instead of randomly
- Query relationships before fetching content
- Build cross-site understanding
- Deliver 10-100x faster responses

**For Publishers:**
- Declare semantic relationships explicitly
- Enable sophisticated agent behavior
- Track graph-based analytics
- Participate in knowledge networks

**For Users:**
- Get contextually relevant answers
- See relationship-based recommendations
- Benefit from cross-site synthesis
- Experience truly intelligent assistance

**The Path Forward:**

1. **Foundation** (Today): ARW discovery enables basic graph construction
2. **Enrichment** (Near-term): Semantic analysis adds deep relationships
3. **Integration** (Mid-term): Protocols create typed graphs
4. **Networks** (Long-term): Cross-site graphs enable web-scale knowledge

The future of the web isn't just agent-ready—**it's graph-native**. ARW provides the infrastructure to get there.

---

**Version:** 1.0
**Date:** January 2025
**Related Documents:**
- [Discovery Architecture](DISCOVERY_ARCHITECTURE.md)
- [ARW Specification](../../spec/ARW-0.1-draft.md)
- [ARW Introduction](../arw-overview/ARW-Introduction.md)

**Contact:** ai@arw.dev

---

## Appendix: Graph Query Examples

### Query 1: Find Learning Path

```cypher
// Given a target topic, find optimal learning path
MATCH path = shortestPath(
  (basics:Page {url: "/docs/basics"})
  -[:PREREQUISITE_FOR*]->(target:Page {url: "/docs/advanced-oauth"})
)
UNWIND nodes(path) as step
RETURN step.url, step.machine_view
ORDER BY length(path)
```

### Query 2: Action Workflow Discovery

```cypher
// Find complete workflow for checking out
MATCH workflow = (start:Action {id: "browse_products"})
                 -[:PRECEDES*]->(end:Action {id: "complete_checkout"})
UNWIND nodes(workflow) as action
RETURN action.id, action.name, action.endpoint, action.auth
```

### Query 3: Cross-Site Product Comparison

```cypher
// Compare same product across multiple sites
MATCH (product:Product {name: "Wireless Mechanical Keyboard"})
      <-[:DESCRIBES_PRODUCT]-(page:Page)
      <-[:HAS_PAGE]-(site:Site)
WITH product, site, page
MATCH (page)-[:HAS_EXTERNAL_REVIEWS]->(reviews:Page)
RETURN
  site.name as retailer,
  product.price as price,
  reviews.rating as review_score,
  page.machine_view as product_page
ORDER BY product.price ASC
```

### Query 4: Topic Clustering

```cypher
// Find all chunks related to authentication
MATCH (chunk:Chunk)-[:MENTIONS_TOPIC]->(topic:Topic)
WHERE topic.name IN ["OAuth", "Authentication", "Security", "JWT"]
WITH chunk, collect(topic.name) as topics
RETURN chunk.page, chunk.heading, chunk.addressable_url, topics
ORDER BY size(topics) DESC
```